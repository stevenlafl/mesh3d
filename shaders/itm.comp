#version 430 core
layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, r32f)  uniform readonly  image2D  uElevation;
layout(binding = 1, r8ui)  uniform writeonly uimage2D uVisibility;
layout(binding = 2, r32f)  uniform writeonly image2D  uSignal;

uniform ivec2 uGridSize;        // (cols, rows)
uniform ivec2 uNodeCell;        // (col, row) of the node
uniform float uObserverHeight;  // node_elev + antenna_height
uniform int   uMaxRangeCells;
uniform float uTxPowerDbm;
uniform float uAntennaGainDbi;
uniform float uFreqMhz;
uniform float uCellMeters;
uniform float uCableLossDb;
uniform float uRxSensitivityDbm;
uniform float uEarthCurveFactor;
uniform float uRxAntennaGainDbi;
uniform float uRxCableLossDb;

/* ITM parameters */
uniform int   uClimate;
uniform float uGroundDielectric;
uniform float uGroundConductivity;
uniform int   uPolarization;
uniform float uTargetHeight;     // default 2.0m

const float PI = 3.141592653589793;
const float RE_M = 6371000.0;
const float K_EFF = 4.0 / 3.0;
const int MAX_PROFILE = 512;

/* Horizon distance for antenna at height h */
float horizon_dist(float h) {
    return sqrt(2.0 * K_EFF * RE_M * max(h, 1.0));
}

/* Free-space path loss in dB */
float fspl(float dist_m, float freq_mhz) {
    float dist_km = dist_m / 1000.0;
    dist_km = max(dist_km, 0.01);
    return 20.0 * log(dist_km) / log(10.0)
         + 20.0 * log(freq_mhz) / log(10.0)
         + 32.44;
}

/* Ground loss from impedance */
float ground_loss(float freq_mhz, float dielectric, float conductivity, int pol) {
    float omega = 2.0 * PI * freq_mhz * 1e6;
    float epsilon0 = 8.854e-12;
    float ratio = conductivity / (omega * epsilon0 * dielectric);
    if (pol == 0) {
        return 2.0 + 3.0 * log(1.0 + ratio) / log(10.0);
    } else {
        return 1.0 + 2.0 * log(1.0 + ratio) / log(10.0);
    }
}

void main() {
    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
    int c = gid.x;
    int r = gid.y;

    if (c >= uGridSize.x || r >= uGridSize.y)
        return;

    int dc = c - uNodeCell.x;
    int dr = r - uNodeCell.y;
    float dist_cells = sqrt(float(dc * dc + dr * dr));

    /* Node's own cell */
    if (dist_cells < 0.5) {
        imageStore(uVisibility, gid, uvec4(1, 0, 0, 0));
        imageStore(uSignal, gid, vec4(-60.0, 0.0, 0.0, 0.0));
        return;
    }

    /* Out of range */
    if (dist_cells > float(uMaxRangeCells)) {
        imageStore(uVisibility, gid, uvec4(0, 0, 0, 0));
        imageStore(uSignal, gid, vec4(-999.0, 0.0, 0.0, 0.0));
        return;
    }

    float d_total = dist_cells * uCellMeters;

    /* Extract terrain profile (up to MAX_PROFILE samples) */
    int n_raw = int(dist_cells) + 1;
    int step = 1;
    if (n_raw > MAX_PROFILE) {
        step = (n_raw + MAX_PROFILE - 1) / MAX_PROFILE;
    }
    int n_profile = min((n_raw + step - 1) / step, MAX_PROFILE);
    float profile_step_m = uCellMeters * float(step);

    /* Sample terrain profile and compute delta_h (terrain roughness) */
    float profile[MAX_PROFILE];
    float p_min = 1e30;
    float p_max = -1e30;

    /* Also find max obstruction (Deygout) for diffraction */
    float max_violation = 0.0;
    float best_t = 0.0;

    for (int i = 0; i < n_profile; ++i) {
        float t = float(i * step) / dist_cells;
        t = min(t, 1.0);
        float sr = float(uNodeCell.y) + float(dr) * t;
        float sc = float(uNodeCell.x) + float(dc) * t;
        int si = clamp(int(sr), 0, uGridSize.y - 1);
        int sj = clamp(int(sc), 0, uGridSize.x - 1);
        float elev = imageLoad(uElevation, ivec2(sj, si)).r;
        profile[i] = elev;

        /* Track min/max for roughness (exclude endpoints) */
        if (i > 0 && i < n_profile - 1) {
            p_min = min(p_min, elev);
            p_max = max(p_max, elev);
        }

        /* Earth-curvature-corrected LOS check */
        if (i > 0 && i < n_profile) {
            float target_elev = imageLoad(uElevation, gid).r;
            float d_along = d_total * t;
            float d_remain = d_total * (1.0 - t);
            float earth_curve = d_along * d_remain * uEarthCurveFactor;
            float needed_h = uObserverHeight + (target_elev - uObserverHeight) * t - earth_curve;
            float violation = elev - needed_h;
            if (violation > max_violation) {
                max_violation = violation;
                best_t = t;
            }
        }
    }

    /* Delta-h: simplified as max-min of interior profile */
    float delta_h = (n_profile > 2) ? max(p_max - p_min, 0.0) : 0.0;

    /* Effective antenna heights */
    float h1 = uObserverHeight - profile[0];
    float h2 = uTargetHeight;
    h1 = max(h1, 1.0);
    h2 = max(h2, 1.0);

    /* Free-space loss */
    float fsl = fspl(d_total, uFreqMhz);

    /* Horizon distances */
    float dl1 = horizon_dist(h1);
    float dl2 = horizon_dist(h2);
    float dls = dl1 + dl2;

    /* Diffraction loss */
    float dfl = 0.0;
    if (max_violation > 0.0) {
        /* Knife-edge diffraction from Deygout obstruction */
        float lambda = 299.792458 / uFreqMhz;
        float d1 = d_total * best_t;
        float d2 = d_total * (1.0 - best_t);
        float d_harmonic = d1 * d2 / (d1 + d2);
        float v = max_violation * sqrt(2.0 / (lambda * d_harmonic));
        if (v > -0.78) {
            dfl = 6.9 + 20.0 * log(sqrt((v - 0.1) * (v - 0.1) + 1.0) + v - 0.1) / log(10.0);
        }
    } else if (d_total > dls) {
        /* Beyond smooth-earth LOS — add smooth-earth diffraction */
        float d_excess = d_total - dls;
        float lambda = 299.792458 / uFreqMhz;
        float v = 2.0 * d_excess / sqrt(lambda * d_total);
        if (v > -0.78) {
            dfl = 6.9 + 20.0 * log(sqrt((v - 0.1) * (v - 0.1) + 1.0) + v - 0.1) / log(10.0);
        }
    }

    /* Ground impedance loss */
    float gnd = ground_loss(uFreqMhz, uGroundDielectric, uGroundConductivity, uPolarization);

    /* Terrain roughness adjustment (ITU-R P.1546 inspired)
       delta_h is the terrain irregularity parameter.
       Stronger scaling to match real-world propagation. */
    float rough_adj = 0.0;
    if (delta_h > 10.0) {
        rough_adj = 10.0 * log(delta_h / 10.0) / log(10.0);
    }

    /* Clutter/environment loss: accounts for ground clutter, vegetation, buildings.
       Scales with distance — longer paths encounter more clutter. */
    float clutter_db = 0.0;
    float dist_km = d_total / 1000.0;
    if (dist_km > 1.0) {
        clutter_db = 6.0 * log(dist_km) / log(10.0); // ~6dB/decade of distance
    }

    /* Multiple obstruction penalty: single knife-edge underestimates loss when
       terrain has multiple ridges. Scale diffraction loss based on roughness. */
    if (dfl > 0.0 && delta_h > 50.0) {
        float multi_ridge_factor = 1.0 + 0.5 * min(delta_h / 200.0, 1.0);
        dfl *= multi_ridge_factor;
    }

    /* Total path loss: always include knife-edge diffraction when obstructed.
       Distance-dependent smooth-earth diffraction only applies to unobstructed paths
       beyond the LOS horizon. */
    float total_loss = fsl + gnd + clutter_db;

    if (max_violation > 0.0) {
        /* Obstructed path — always apply knife-edge diffraction regardless of distance */
        total_loss += dfl;
    } else if (d_total > dls) {
        /* Unobstructed but beyond smooth-earth horizon — smooth-earth diffraction */
        total_loss += dfl;
    }

    total_loss += rough_adj;

    /* EIRP and received signal */
    float eirp = uTxPowerDbm + uAntennaGainDbi - uCableLossDb;
    float received = eirp - total_loss + uRxAntennaGainDbi - uRxCableLossDb;

    if (received >= uRxSensitivityDbm) {
        imageStore(uVisibility, gid, uvec4(1, 0, 0, 0));
    } else {
        imageStore(uVisibility, gid, uvec4(0, 0, 0, 0));
    }
    imageStore(uSignal, gid, vec4(received, 0.0, 0.0, 0.0));
}
